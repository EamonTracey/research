TaskVine is a framework for building large scale distributed data intensive applications that run on clusters, clouds, grids, and similar distributed systems. A TaskVine application consists of a main program that creates a Manager object, and then submits Task objects that use file objects representing data sources. The manager distributes tasks across available workers and returns results to the main application.

Below is documentation for the TaskVine Python module. It contains the method signatures for the Manager and Task classes.

ndcctools.taskvine.manager.Manager
    __init__(self, port=9123, name=None, shutdown=False, run_info_path='vine-run-info', staging_path=None, ssl=None, init_fn=None, status_display_interval=None)
    application_info(self)
    blacklist(self, host)
    blacklist_clear(self, host=None)
    blacklist_with_timeout(self, host, timeout)
    block_host(self, host)
    block_host_with_timeout(self, host, timeout)
    cancel_all(self)
    cancel_by_category(self, category)
    cancel_by_task_id(self, id)
    cancel_by_task_tag(self, tag)
    check_library_exists(self, library_name)
    create_library_from_command(self, executable_path, name, env=None)
    create_library_from_functions(self, library_name, *function_list, poncho_env=None, init_command=None, add_env=True, hoisting_modules=None)
    create_library_from_serverized_files(self, library_name, library_path, env=None)
    declare_buffer(self, buffer=None, cache=False, peer_transfer=True)
    declare_chirp(self, server, source, ticket=None, env=None, cache=False, peer_transfer=True)
    declare_file(self, path, cache=False, peer_transfer=True, unlink_when_done=False)
    declare_minitask(self, minitask, source, cache=False, peer_transfer=True)
    declare_poncho(self, package, cache=False, peer_transfer=True)
    declare_starch(self, starch, cache=False, peer_transfer=True)
    declare_temp(self)
    declare_untar(self, tarball, cache=False, peer_transfer=True)
    declare_url(self, url, cache=False, peer_transfer=True)
    declare_xrootd(self, source, proxy=None, env=None, cache=False, peer_transfer=True)
    disable_peer_transfers(self)
    empty(self)
    enable_disconnect_slow_workers(self, multiplier)
    enable_disconnect_slow_workers_category(self, name, multiplier)
    enable_monitoring(self, watchdog=True, time_series=False)
    enable_peer_transfers(self)
    fetch_file(self, file)
    hungry(self)
    initialize_categories(self, filename, rm)
    install_library(self, task)
    log_debug_app(self, entry)
    log_txn_app(self, entry)
    map(self, fn, seq, chunksize=1)
    pair(self, fn, seq1, seq2, chunksize=1, env=None)
    prune_file(self, file)
    remote_map(self, fn, seq, library, name, chunksize=1)
    remote_pair(self, fn, seq1, seq2, library, name, chunksize=1)
    remote_tree_reduce(self, fn, seq, library, name, chunksize=2)
    remove_file(self, file)
    remove_library(self, name)
    set_catalog_servers(self, catalogs)
    set_category_autolabel_resource(self, category, resource, autolabel)
    set_category_first_allocation_guess(self, category, rmd)
    set_category_max_concurrent(self, category, max_concurrent)
    set_category_mode(self, category, mode)
    set_category_resources_max(self, category, rmd)
    set_category_resources_min(self, category, rmd)
    set_draining_by_hostname(self, hostname, drain_mode=True)
    set_keepalive_interval(self, interval)
    set_keepalive_timeout(self, timeout)
    set_manager_preferred_connection(self, mode)
    set_min_task_id(self, minid)
    set_name(self, name)
    set_password(self, password)
    set_password_file(self, file)
    set_priority(self, priority)
    set_property(self, name, value)
    set_resources_max(self, rmd)
    set_resources_min(self, rmd)
    set_runtime_info_path(self, dirname)
    set_scheduler(self, scheduler)
    stats_category(self, category)
    status(self, request)
    submit(self, task)
    summarize_workers(self)
    task_state(self, task_id)
    tasks_left_count(self, ntasks)
    tree_reduce(self, fn, seq, chunksize=2)
    tune(self, name, value)
    unblock_host(self, host=None)
    undeclare_file(self, file)
    undeclare_function(self, fn)
    update_catalog(self)
    wait(self, timeout='wait_forever')
    wait_for_tag(self, tag, timeout='wait_forever')
    wait_for_task_id(self, task_id, timeout='wait_forever')
    workers_shutdown(self, n=0)
ndcctools.taskvine.manager.Manager
    __init__(self, port=9123, name=None, shutdown=False, run_info_path='vine-run-info', staging_path=None, ssl=None, init_fn=None, status_display_interval=None)
    application_info(self)
    blacklist(self, host)
    blacklist_clear(self, host=None)
    blacklist_with_timeout(self, host, timeout)
    block_host(self, host)
    block_host_with_timeout(self, host, timeout)
    cancel_all(self)
    cancel_by_category(self, category)
    cancel_by_task_id(self, id)
    cancel_by_task_tag(self, tag)
    check_library_exists(self, library_name)
    create_library_from_command(self, executable_path, name, env=None)
    create_library_from_functions(self, library_name, *function_list, poncho_env=None, init_command=None, add_env=True, hoisting_modules=None)
    create_library_from_serverized_files(self, library_name, library_path, env=None)
    declare_buffer(self, buffer=None, cache=False, peer_transfer=True)
    declare_chirp(self, server, source, ticket=None, env=None, cache=False, peer_transfer=True)
    declare_file(self, path, cache=False, peer_transfer=True, unlink_when_done=False)
    declare_minitask(self, minitask, source, cache=False, peer_transfer=True)
    declare_poncho(self, package, cache=False, peer_transfer=True)
    declare_starch(self, starch, cache=False, peer_transfer=True)
    declare_temp(self)
    declare_untar(self, tarball, cache=False, peer_transfer=True)
    declare_url(self, url, cache=False, peer_transfer=True)
    declare_xrootd(self, source, proxy=None, env=None, cache=False, peer_transfer=True)
    disable_peer_transfers(self)
    empty(self)
    enable_disconnect_slow_workers(self, multiplier)
    enable_disconnect_slow_workers_category(self, name, multiplier)
    enable_monitoring(self, watchdog=True, time_series=False)
    enable_peer_transfers(self)
    fetch_file(self, file)
    hungry(self)
    initialize_categories(self, filename, rm)
    install_library(self, task)
    log_debug_app(self, entry)
    log_txn_app(self, entry)
    map(self, fn, seq, chunksize=1)
    pair(self, fn, seq1, seq2, chunksize=1, env=None)
    prune_file(self, file)
    remote_map(self, fn, seq, library, name, chunksize=1)
    remote_pair(self, fn, seq1, seq2, library, name, chunksize=1)
    remote_tree_reduce(self, fn, seq, library, name, chunksize=2)
    remove_file(self, file)
    remove_library(self, name)
    set_catalog_servers(self, catalogs)
    set_category_autolabel_resource(self, category, resource, autolabel)
    set_category_first_allocation_guess(self, category, rmd)
    set_category_max_concurrent(self, category, max_concurrent)
    set_category_mode(self, category, mode)
    set_category_resources_max(self, category, rmd)
    set_category_resources_min(self, category, rmd)
    set_draining_by_hostname(self, hostname, drain_mode=True)
    set_keepalive_interval(self, interval)
    set_keepalive_timeout(self, timeout)
    set_manager_preferred_connection(self, mode)
    set_min_task_id(self, minid)
    set_name(self, name)
    set_password(self, password)
    set_password_file(self, file)
    set_priority(self, priority)
    set_property(self, name, value)
    set_resources_max(self, rmd)
    set_resources_min(self, rmd)
    set_runtime_info_path(self, dirname)
    set_scheduler(self, scheduler)
    stats_category(self, category)
    status(self, request)
    submit(self, task)
    summarize_workers(self)
    task_state(self, task_id)
    tasks_left_count(self, ntasks)
    tree_reduce(self, fn, seq, chunksize=2)
    tune(self, name, value)
    unblock_host(self, host=None)
    undeclare_file(self, file)
    undeclare_function(self, fn)
    update_catalog(self)
    wait(self, timeout='wait_forever')
    wait_for_tag(self, tag, timeout='wait_forever')
    wait_for_task_id(self, task_id, timeout='wait_forever')
    workers_shutdown(self, n=0)
