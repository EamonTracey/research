{
    "system": "You are a helpful TaskVine coding assistant. Provide strictly the requested code using the ndcctools.taskvine library. The API reference is below.\nndcctools.taskvine.manager.Manager\n    __init__(self, port=9123, name=None, shutdown=False, run_info_path='vine-run-info', staging_path=None, ssl=None, init_fn=None, status_display_interval=None)\n    application_info(self)\n    blacklist(self, host)\n    blacklist_clear(self, host=None)\n    blacklist_with_timeout(self, host, timeout)\n    block_host(self, host)\n    block_host_with_timeout(self, host, timeout)\n    cancel_all(self)\n    cancel_by_category(self, category)\n    cancel_by_task_id(self, id)\n    cancel_by_task_tag(self, tag)\n    check_library_exists(self, library_name)\n    create_library_from_command(self, executable_path, name, env=None)\n    create_library_from_functions(self, library_name, *function_list, poncho_env=None, init_command=None, add_env=True, hoisting_modules=None)\n    create_library_from_serverized_files(self, library_name, library_path, env=None)\n    declare_buffer(self, buffer=None, cache=False, peer_transfer=True)\n    declare_chirp(self, server, source, ticket=None, env=None, cache=False, peer_transfer=True)\n    declare_file(self, path, cache=False, peer_transfer=True, unlink_when_done=False)\n    declare_minitask(self, minitask, source, cache=False, peer_transfer=True)\n    declare_poncho(self, package, cache=False, peer_transfer=True)\n    declare_starch(self, starch, cache=False, peer_transfer=True)\n    declare_temp(self)\n    declare_untar(self, tarball, cache=False, peer_transfer=True)\n    declare_url(self, url, cache=False, peer_transfer=True)\n    declare_xrootd(self, source, proxy=None, env=None, cache=False, peer_transfer=True)\n    disable_peer_transfers(self)\n    empty(self)\n    enable_disconnect_slow_workers(self, multiplier)\n    enable_disconnect_slow_workers_category(self, name, multiplier)\n    enable_monitoring(self, watchdog=True, time_series=False)\n    enable_peer_transfers(self)\n    fetch_file(self, file)\n    hungry(self)\n    initialize_categories(self, filename, rm)\n    install_library(self, task)\n    log_debug_app(self, entry)\n    log_txn_app(self, entry)\n    map(self, fn, seq, chunksize=1)\n    pair(self, fn, seq1, seq2, chunksize=1, env=None)\n    prune_file(self, file)\n    remote_map(self, fn, seq, library, name, chunksize=1)\n    remote_pair(self, fn, seq1, seq2, library, name, chunksize=1)\n    remote_tree_reduce(self, fn, seq, library, name, chunksize=2)\n    remove_file(self, file)\n    remove_library(self, name)\n    set_catalog_servers(self, catalogs)\n    set_category_autolabel_resource(self, category, resource, autolabel)\n    set_category_first_allocation_guess(self, category, rmd)\n    set_category_max_concurrent(self, category, max_concurrent)\n    set_category_mode(self, category, mode)\n    set_category_resources_max(self, category, rmd)\n    set_category_resources_min(self, category, rmd)\n    set_draining_by_hostname(self, hostname, drain_mode=True)\n    set_keepalive_interval(self, interval)\n    set_keepalive_timeout(self, timeout)\n    set_manager_preferred_connection(self, mode)\n    set_min_task_id(self, minid)\n    set_name(self, name)\n    set_password(self, password)\n    set_password_file(self, file)\n    set_priority(self, priority)\n    set_property(self, name, value)\n    set_resources_max(self, rmd)\n    set_resources_min(self, rmd)\n    set_runtime_info_path(self, dirname)\n    set_scheduler(self, scheduler)\n    stats_category(self, category)\n    status(self, request)\n    submit(self, task)\n    summarize_workers(self)\n    task_state(self, task_id)\n    tasks_left_count(self, ntasks)\n    tree_reduce(self, fn, seq, chunksize=2)\n    tune(self, name, value)\n    unblock_host(self, host=None)\n    undeclare_file(self, file)\n    undeclare_function(self, fn)\n    update_catalog(self)\n    wait(self, timeout='wait_forever')\n    wait_for_tag(self, tag, timeout='wait_forever')\n    wait_for_task_id(self, task_id, timeout='wait_forever')\n    workers_shutdown(self, n=0)\nndcctools.taskvine.task.Task\n    __init__(self, command, **task_info)\n    add_environment(self, f)\n    add_execution_context(self, f)\n    add_feature(self, name)\n    add_input(self, file, remote_name, strict_input=False, mount_symlink=False)\n    add_nopen(self, manager)\n    add_output(self, file, remote_name, watch=False, failure_only=None, success_only=None)\n    add_poncho_package(self, file)\n    add_starch_package(self, file)\n    clone(self)\n    completed(self)\n    get_library_required(self)\n    get_libray_provided(self)\n    get_metric(self, name)\n    needs_library(self, library)\n    provides_library(self, library)\n    set_category(self, name)\n    set_command(self, command)\n    set_cores(self, cores)\n    set_disk(self, disk)\n    set_env_var(self, name, value=None)\n    set_function_slots(self, nslots)\n    set_gpus(self, gpus)\n    set_library_provided(self, library_name)\n    set_library_required(self, library)\n    set_max_forsaken(self, max_forsaken)\n    set_memory(self, memory)\n    set_monitor_output(self, directory)\n    set_priority(self, priority)\n    set_retries(self, max_retries)\n    set_scheduler(self, scheduler)\n    set_snapshot_file(self, filename)\n    set_tag(self, tag)\n    set_time_end(self, useconds)\n    set_time_max(self, useconds)\n    set_time_min(self, seconds)\n    set_time_start(self, useconds)\n    submit_finalize(self)\n    successful(self)\nndcctools.taskvine.task.LibraryTask\n    __init__(self, fn, library_name)\n    add_environment(self, f)\n    add_execution_context(self, f)\n    add_feature(self, name)\n    add_input(self, file, remote_name, strict_input=False, mount_symlink=False)\n    add_nopen(self, manager)\n    add_output(self, file, remote_name, watch=False, failure_only=None, success_only=None)\n    add_poncho_package(self, file)\n    add_starch_package(self, file)\n    clone(self)\n    completed(self)\n    get_library_required(self)\n    get_libray_provided(self)\n    get_metric(self, name)\n    needs_library(self, library)\n    provides_library(self, library)\n    set_category(self, name)\n    set_command(self, command)\n    set_cores(self, cores)\n    set_disk(self, disk)\n    set_env_var(self, name, value=None)\n    set_function_slots(self, nslots)\n    set_gpus(self, gpus)\n    set_library_provided(self, library_name)\n    set_library_required(self, library)\n    set_max_forsaken(self, max_forsaken)\n    set_memory(self, memory)\n    set_monitor_output(self, directory)\n    set_priority(self, priority)\n    set_retries(self, max_retries)\n    set_scheduler(self, scheduler)\n    set_snapshot_file(self, filename)\n    set_tag(self, tag)\n    set_time_end(self, useconds)\n    set_time_max(self, useconds)\n    set_time_min(self, seconds)\n    set_time_start(self, useconds)\n    submit_finalize(self)\n    successful(self)\nndcctools.taskvine.task.PythonTask\n    __init__(self, func, *args, **kwargs)\n    add_environment(self, f)\n    add_execution_context(self, f)\n    add_feature(self, name)\n    add_input(self, file, remote_name, strict_input=False, mount_symlink=False)\n    add_nopen(self, manager)\n    add_output(self, file, remote_name, watch=False, failure_only=None, success_only=None)\n    add_poncho_package(self, file)\n    add_starch_package(self, file)\n    clone(self)\n    completed(self)\n    disable_output_serialization(self)\n    disable_temp_output(self)\n    enable_temp_output(self)\n    get_library_required(self)\n    get_libray_provided(self)\n    get_metric(self, name)\n    needs_library(self, library)\n    provides_library(self, library)\n    set_category(self, name)\n    set_command(self, command)\n    set_cores(self, cores)\n    set_disk(self, disk)\n    set_env_var(self, name, value=None)\n    set_function_slots(self, nslots)\n    set_gpus(self, gpus)\n    set_library_provided(self, library_name)\n    set_library_required(self, library)\n    set_max_forsaken(self, max_forsaken)\n    set_memory(self, memory)\n    set_monitor_output(self, directory)\n    set_output_cache(self, cache=False)\n    set_priority(self, priority)\n    set_retries(self, max_retries)\n    set_scheduler(self, scheduler)\n    set_snapshot_file(self, filename)\n    set_tag(self, tag)\n    set_time_end(self, useconds)\n    set_time_max(self, useconds)\n    set_time_min(self, seconds)\n    set_time_start(self, useconds)\n    submit_finalize(self)\n    successful(self)\nndcctools.taskvine.task.FunctionCall\n    __init__(self, library, fn, *args, **kwargs)\n    add_environment(self, f)\n    add_execution_context(self, f)\n    add_feature(self, name)\n    add_input(self, file, remote_name, strict_input=False, mount_symlink=False)\n    add_nopen(self, manager)\n    add_output(self, file, remote_name, watch=False, failure_only=None, success_only=None)\n    add_poncho_package(self, file)\n    add_starch_package(self, file)\n    clone(self)\n    completed(self)\n    disable_output_serialization(self)\n    disable_temp_output(self)\n    enable_temp_output(self)\n    get_library_required(self)\n    get_libray_provided(self)\n    get_metric(self, name)\n    needs_library(self, library)\n    provides_library(self, library)\n    set_category(self, name)\n    set_command(self, command)\n    set_cores(self, cores)\n    set_disk(self, disk)\n    set_env_var(self, name, value=None)\n    set_exec_method(self, remote_task_exec_method)\n    set_fn_args(self, args=[], kwargs={})\n    set_function_slots(self, nslots)\n    set_gpus(self, gpus)\n    set_library_provided(self, library_name)\n    set_library_required(self, library)\n    set_max_forsaken(self, max_forsaken)\n    set_memory(self, memory)\n    set_monitor_output(self, directory)\n    set_output_cache(self, cache=False)\n    set_priority(self, priority)\n    set_retries(self, max_retries)\n    set_scheduler(self, scheduler)\n    set_snapshot_file(self, filename)\n    set_tag(self, tag)\n    set_time_end(self, useconds)\n    set_time_max(self, useconds)\n    set_time_min(self, seconds)\n    set_time_start(self, useconds)\n    submit_finalize(self)\n    successful(self)\nndcctools.taskvine.futures.FuturesExecutor\n    __init__(self, port=9123, batch_type='local', manager=None, manager_host_port=None, manager_name=None, factory_binary=None, worker_binary=None, log_file='/dev/null', factory=True, opts={})\n    create_library_from_functions(self, name, *function_list, poncho_env=None, init_command=None, add_env=True, hoisting_modules=None)\n    future_funcall(self, library_name, fn, *args, **kwargs)\n    future_task(self, fn, *args, **kwargs)\n    get(self, name)\n    install_library(self, libtask)\n    map(self, fn, *iterables, timeout=None, chunksize=1)\n    set(self, name, value)\n    shutdown(self, wait=True, *, cancel_futures=False)\n    submit(self, fn, *args, **kwargs)\nndcctools.taskvine.futures.VineFuture\n    __init__(self, task)\n    add_done_callback(self, fn)\n    cancel(self)\n    cancelled(self)\n    done(self)\n    exception(self, timeout=None)\n    result(self, timeout='wait_forever')\n    running(self)\n    set_exception(self, exception)\n    set_result(self, result)\n    set_running_or_notify_cancel(self)\nndcctools.taskvine.futures.FuturePythonTask\n    __init__(self, manager, func, *args, **kwargs)\n    add_environment(self, f)\n    add_execution_context(self, f)\n    add_feature(self, name)\n    add_input(self, file, remote_name, strict_input=False, mount_symlink=False)\n    add_nopen(self, manager)\n    add_output(self, file, remote_name, watch=False, failure_only=None, success_only=None)\n    add_poncho_package(self, file)\n    add_starch_package(self, file)\n    clone(self)\n    completed(self)\n    disable_output_serialization(self)\n    disable_temp_output(self)\n    enable_temp_output(self)\n    get_library_required(self)\n    get_libray_provided(self)\n    get_metric(self, name)\n    needs_library(self, library)\n    output(self, timeout='wait_forever')\n    provides_library(self, library)\n    set_category(self, name)\n    set_command(self, command)\n    set_cores(self, cores)\n    set_disk(self, disk)\n    set_env_var(self, name, value=None)\n    set_function_slots(self, nslots)\n    set_gpus(self, gpus)\n    set_library_provided(self, library_name)\n    set_library_required(self, library)\n    set_max_forsaken(self, max_forsaken)\n    set_memory(self, memory)\n    set_monitor_output(self, directory)\n    set_output_cache(self, cache=False)\n    set_priority(self, priority)\n    set_retries(self, max_retries)\n    set_scheduler(self, scheduler)\n    set_snapshot_file(self, filename)\n    set_tag(self, tag)\n    set_time_end(self, useconds)\n    set_time_max(self, useconds)\n    set_time_min(self, seconds)\n    set_time_start(self, useconds)\n    submit_finalize(self)\n    successful(self)\nndcctools.taskvine.futures.FutureFunctionCall\n    __init__(self, manager, library_name, fn, *args, **kwargs)\n    add_environment(self, f)\n    add_execution_context(self, f)\n    add_feature(self, name)\n    add_input(self, file, remote_name, strict_input=False, mount_symlink=False)\n    add_nopen(self, manager)\n    add_output(self, file, remote_name, watch=False, failure_only=None, success_only=None)\n    add_poncho_package(self, file)\n    add_starch_package(self, file)\n    clone(self)\n    completed(self)\n    disable_output_serialization(self)\n    disable_temp_output(self)\n    enable_temp_output(self)\n    get_library_required(self)\n    get_libray_provided(self)\n    get_metric(self, name)\n    needs_library(self, library)\n    output(self, timeout='wait_forever')\n    provides_library(self, library)\n    set_category(self, name)\n    set_command(self, command)\n    set_cores(self, cores)\n    set_disk(self, disk)\n    set_env_var(self, name, value=None)\n    set_exec_method(self, remote_task_exec_method)\n    set_fn_args(self, args=[], kwargs={})\n    set_function_slots(self, nslots)\n    set_gpus(self, gpus)\n    set_library_provided(self, library_name)\n    set_library_required(self, library)\n    set_max_forsaken(self, max_forsaken)\n    set_memory(self, memory)\n    set_monitor_output(self, directory)\n    set_output_cache(self, cache=False)\n    set_priority(self, priority)\n    set_retries(self, max_retries)\n    set_scheduler(self, scheduler)\n    set_snapshot_file(self, filename)\n    set_tag(self, tag)\n    set_time_end(self, useconds)\n    set_time_max(self, useconds)\n    set_time_min(self, seconds)\n    set_time_start(self, useconds)\n    submit_finalize(self)\n    successful(self)\n",
    "prompts": [
        {
            "id": "taskvine0",
            "content": "Write a Python TaskVine application to get the current date on a worker machine. The date must be stored to an output file named \"current_date\".",
            "response": "```python\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import Task\n\n# Create a TaskVine manager\nmanager = Manager()\n\n# Define the command to get the current date\ncommand = \"date > current_date\"\n\n# Create a TaskVine task\ntask = Task(command)\n\n# Specify the output file\ntask.add_output(\"current_date\", \"current_date\")\n\n# Submit the task to the manager\nmanager.submit(task)\n\n# Wait for the task to complete\nmanager.wait_for_task_id(task.id)\n\n# Check if the task was successful\nif task.successful():\n    print(\"Task completed successfully. The current date is stored in 'current_date'.\")\nelse:\n    print(\"Task failed.\")\n```"
        },
        {
            "id": "taskvine1",
            "content": "Write a Python TaskVine application to count the number of times the keywords \"wealth\", \"nation\", \"labour\", \"price\", \"nature\", and \"commodity\" appear in Adam Smith's Wealth of Nations. The text is available at \"https://www.gutenberg.org/cache/epub/3300/pg3300.txt\".",
            "response": "```python\nimport requests\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import PythonTask\n\n# Define the keywords to search for\nkeywords = [\"wealth\", \"nation\", \"labour\", \"price\", \"nature\", \"commodity\"]\n\n# Function to count keywords in the text\ndef count_keywords(text, keywords):\n    counts = {keyword: text.lower().count(keyword) for keyword in keywords}\n    return counts\n\n# Download the text of \"Wealth of Nations\"\nresponse = requests.get(\"https://www.gutenberg.org/cache/epub/3300/pg3300.txt\")\ntext = response.text\n\n# Create a TaskVine manager\nmanager = Manager()\n\n# Create a PythonTask to count the keywords\ntask = PythonTask(count_keywords, text, keywords)\n\n# Submit the task to the manager\nmanager.submit(task)\n\n# Wait for the task to complete\nmanager.wait_for_task_id(task.id)\n\n# Check if the task was successful and print the result\nif task.successful():\n    result = task.completed()\n    print(\"Keyword counts:\", result)\nelse:\n    print(\"Task failed.\")\n```"
        },
        {
            "id": "taskvine2",
            "content": "Write a Python TaskVine application to run my program \"script.sh\" with various input arguments and organizes all output data. \"script.sh\" takes, as input, an integer and two files. \"script.sh\" outputs a file named \"output{i}.txt\" where \"{i}\" is the input integer. The application must run \"script.sh\" with input integers 1-1000 and input files \"file1.input\" and \"file2.input\" which are stored in the directory \"script_inputs\". The application must store all output files in a directory named \"script_outputs\".",
            "response": "```python\nimport os\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import Task\n\n# Create directories for inputs and outputs\ninput_dir = \"script_inputs\"\noutput_dir = \"script_outputs\"\nos.makedirs(output_dir, exist_ok=True)\n\n# Initialize TaskVine manager\nmanager = Manager()\n\n# Declare input files\nfile1 = manager.declare_file(os.path.join(input_dir, \"file1.input\"))\nfile2 = manager.declare_file(os.path.join(input_dir, \"file2.input\"))\n\n# Submit tasks for each integer from 1 to 1000\nfor i in range(1, 1001):\n    task = Task(f\"./script.sh {i} file1.input file2.input\")\n    task.add_input(file1, \"file1.input\")\n    task.add_input(file2, \"file2.input\")\n    task.add_output(f\"output{i}.txt\", os.path.join(output_dir, f\"output{i}.txt\"))\n    manager.submit(task)\n\n# Wait for all tasks to complete\nmanager.wait()\n```"
        },
        {
            "id": "taskvine3",
            "content": "Write a Python TaskVine application to execute a pipeline of shell scripts. I have the script \"script1.sh\" which outputs a file named \"intermediary.out\" upon completion. I also have the scripts \"script2.sh\" and \"script3.sh\"  which both accept an input file as a command line argument. \"script2.sh\" and \"script3.sh\" must both receive \"intermediary.out\" as the input. Finally, \"script2.sh\" and \"script3.sh\" output files named \"script2.out\" and \"script3.out\", respectively. Save these outputs files on the host machine. \"intermediary.out\" need not be saved to the host machine.",
            "response": "```python\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import Task\n\n# Initialize the TaskVine manager\nmanager = Manager()\n\n# Task 1: Execute script1.sh\ntask1 = Task(command=\"./script1.sh\")\ntask1.add_output(\"intermediary.out\", \"intermediary.out\", success_only=True)\n\n# Task 2: Execute script2.sh with intermediary.out as input\ntask2 = Task(command=\"./script2.sh intermediary.out\")\ntask2.add_input(\"intermediary.out\", \"intermediary.out\")\ntask2.add_output(\"script2.out\", \"script2.out\", success_only=True)\n\n# Task 3: Execute script3.sh with intermediary.out as input\ntask3 = Task(command=\"./script3.sh intermediary.out\")\ntask3.add_input(\"intermediary.out\", \"intermediary.out\")\ntask3.add_output(\"script3.out\", \"script3.out\", success_only=True)\n\n# Submit tasks to the manager\nmanager.submit(task1)\nmanager.submit(task2)\nmanager.submit(task3)\n\n# Wait for all tasks to complete\nmanager.wait()\n\n# Shutdown the manager\nmanager.shutdown()\n```"
        },
        {
            "id": "taskvine4",
            "content": "Write a Python TaskVine application to run my GPU-accelerated program. The program binary is stored at \"./train_demo\". The program requires that the worker machine has the feature \"NVIDIA RTX 4090\". Upon completion, the program outputs \"model.tar.gz\". The output file must be saved to the host machine.",
            "response": "```python\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import Task\n\n# Initialize the TaskVine manager\nmanager = Manager()\n\n# Create a task for the GPU-accelerated program\ntask = Task(command=\"./train_demo\")\n\n# Add the required feature for the task\ntask.add_feature(\"NVIDIA RTX 4090\")\n\n# Specify the output file to be saved to the host machine\ntask.add_output(\"model.tar.gz\", \"model.tar.gz\")\n\n# Set the number of GPUs required\ntask.set_gpus(1)\n\n# Submit the task to the manager\nmanager.submit(task)\n\n# Wait for the task to complete\nmanager.wait_for_task_id(task.id)\n\n# Check if the task was successful\nif task.successful():\n    print(\"Task completed successfully and model.tar.gz has been saved.\")\nelse:\n    print(\"Task failed.\")\n```"
        },
        {
            "id": "taskvine5",
            "content": "Write a Python TaskVine application to compile and test my project stored at \"complex_project/\". To compile the project, run the \"make all\" command in the project's root directory. Then, to test the project, run \"make test\". The compilation and test must use at most 4 cores, 1024 MB of memory, and 2048 MB of disk. Enable resource monitoring to track resource usage, but do not terminate the task if it overuses resources. When the task completes, print the task's exit code and standard output. For each resource that the task overused, print the resource and by how much it overused.",
            "response": "```python\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import Task\n\ndef main():\n    # Initialize the TaskVine manager\n    manager = Manager()\n\n    # Create a task to compile and test the project\n    task = Task(command=\"make all && make test\", tag=\"compile_and_test\")\n\n    # Set resource limits\n    task.set_cores(4)\n    task.set_memory(1024)\n    task.set_disk(2048)\n\n    # Enable resource monitoring\n    task.set_monitor_output(\"resource_usage\")\n\n    # Add the project directory as input\n    task.add_input(\"complex_project/\", \"complex_project/\")\n\n    # Submit the task\n    manager.submit(task)\n\n    # Wait for the task to complete\n    manager.wait_for_tag(\"compile_and_test\")\n\n    # Check if the task completed successfully\n    if task.completed():\n        # Print the task's exit code and standard output\n        print(\"Exit Code:\", task.get_metric(\"exit_code\"))\n        print(\"Standard Output:\", task.get_metric(\"stdout\"))\n\n        # Check for resource overuse\n        for resource in [\"cores\", \"memory\", \"disk\"]:\n            used = task.get_metric(f\"used_{resource}\")\n            limit = task.get_metric(f\"limit_{resource}\")\n            if used > limit:\n                print(f\"Overused {resource}: {used - limit} units\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        },
        {
            "id": "taskvine6",
            "content": "Write a Python TaskVine application that executes multiple programs with different levels of resource requirements. The two task categories must be named \"intensive\" and \"light\". The \"intensive\" tasks require 8 cores and 16 GB of memory. The \"light\" tasks require 1 core and 2 GB of memory. In the intensive category, submit 10 tasks to execute the shell script \"intensive.sh\". In the light category, submit 100 tasks to execute the shell script \"light.sh\" Print the standard output of each task upon completion.",
            "response": "```python\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import Task\n\ndef main():\n    manager = Manager()\n\n    # Set up categories with resource requirements\n    manager.set_category_resources_min(\"intensive\", {\"cores\": 8, \"memory\": 16 * 1024})\n    manager.set_category_resources_min(\"light\", {\"cores\": 1, \"memory\": 2 * 1024})\n\n    # Submit intensive tasks\n    for i in range(10):\n        task = Task(command=\"./intensive.sh\")\n        task.set_category(\"intensive\")\n        task.set_cores(8)\n        task.set_memory(16 * 1024)\n        manager.submit(task)\n\n    # Submit light tasks\n    for i in range(100):\n        task = Task(command=\"./light.sh\")\n        task.set_category(\"light\")\n        task.set_cores(1)\n        task.set_memory(2 * 1024)\n        manager.submit(task)\n\n    # Wait for all tasks to complete and print their output\n    manager.wait()\n\n    for task in manager.tasks_left_count(0):\n        if task.completed():\n            print(f\"Task {task} output:\")\n            print(task.get_output())\n\nif __name__ == \"__main__\":\n    main()\n```"
        },
        {
            "id": "taskvine7",
            "content": "Write a Python TaskVine application to perform matrix inversion and transposition. The matrix computations must be defined in Python functions and added to a TaskVine library called \"matrix_library\". The user must specify the size, m x n,  of the matrix and the number of matrices, i, on which to perform computation. The application must randomly generate i matrices and for each matrix, print the matrix, print the inverse matrix, and print the transposed matrix.",
            "response": "```python\nimport numpy as np\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import FunctionCall\n\ndef invert_matrix(matrix):\n    return np.linalg.inv(matrix)\n\ndef transpose_matrix(matrix):\n    return np.transpose(matrix)\n\ndef generate_random_matrix(m, n):\n    return np.random.rand(m, n)\n\ndef main():\n    # User inputs\n    m = int(input(\"Enter the number of rows (m): \"))\n    n = int(input(\"Enter the number of columns (n): \"))\n    i = int(input(\"Enter the number of matrices: \"))\n\n    # Initialize TaskVine manager\n    manager = Manager()\n\n    # Create a library with the matrix functions\n    manager.create_library_from_functions(\"matrix_library\", invert_matrix, transpose_matrix)\n\n    for _ in range(i):\n        # Generate a random matrix\n        matrix = generate_random_matrix(m, n)\n        print(\"Original Matrix:\\n\", matrix)\n\n        # Create tasks for inversion and transposition\n        invert_task = FunctionCall(\"matrix_library\", \"invert_matrix\", matrix)\n        transpose_task = FunctionCall(\"matrix_library\", \"transpose_matrix\", matrix)\n\n        # Submit tasks\n        manager.submit(invert_task)\n        manager.submit(transpose_task)\n\n        # Wait for tasks to complete\n        manager.wait_for_task_id(invert_task)\n        manager.wait_for_task_id(transpose_task)\n\n        # Get results\n        inverse_matrix = invert_task.result()\n        transposed_matrix = transpose_task.result()\n\n        # Print results\n        print(\"Inverse Matrix:\\n\", inverse_matrix)\n        print(\"Transposed Matrix:\\n\", transposed_matrix)\n\n    # Shutdown the manager\n    manager.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n```"
        },
        {
            "id": "taskvine8",
            "content": "Write a Python Taskvine application to fetch the titles of multiple news webpages. The webpage contents must be downloaded asynchronously using the TaskVine futures executor. Print the URL and title of each webpage in order of the completion of each task. The webpages I am interested in are \"https://abcnews.com\", \"https://apnews.com\", \"https://axios.com\", \"https://cnn.com\", \"https://nbcnews.com\", \"https://nytimes.com\", \"https://reuters.com\", \"https://washingtonpost.com\", \"https://wsj.com\".",
            "response": "```python\nimport requests\nfrom bs4 import BeautifulSoup\nfrom ndcctools.taskvine.futures import FuturesExecutor\n\ndef fetch_title(url):\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        soup = BeautifulSoup(response.content, 'html.parser')\n        title = soup.title.string if soup.title else 'No title found'\n        return url, title\n    except Exception as e:\n        return url, f\"Error: {str(e)}\"\n\nurls = [\n    \"https://abcnews.com\",\n    \"https://apnews.com\",\n    \"https://axios.com\",\n    \"https://cnn.com\",\n    \"https://nbcnews.com\",\n    \"https://nytimes.com\",\n    \"https://reuters.com\",\n    \"https://washingtonpost.com\",\n    \"https://wsj.com\"\n]\n\nexecutor = FuturesExecutor()\n\nfutures = [executor.submit(fetch_title, url) for url in urls]\n\nfor future in futures:\n    url, title = future.result()\n    print(f\"URL: {url}, Title: {title}\")\n\nexecutor.shutdown()\n```"
        },
        {
            "id": "taskvine9",
            "content": "Write a Python TaskVine application to get the current date on a worker machine. The date must be stored to an output file named \"current_date\". To prevent an unwanted worker from connecting to the manager, use the password stored in the file \"taskvine.password\". Further, encrypt communication between the manager and worker with SSL using the \"key.pem\" and \"certificate.pem\" files.",
            "response": "```python\nfrom ndcctools.taskvine.manager import Manager\nfrom ndcctools.taskvine.task import Task\n\n# Initialize the manager with SSL and password settings\nmanager = Manager(\n    ssl=(\"key.pem\", \"certificate.pem\"),\n    shutdown=True\n)\nmanager.set_password_file(\"taskvine.password\")\n\n# Create a task to get the current date\ntask = Task(\"date > current_date\")\n\n# Add the task to the manager\nmanager.submit(task)\n\n# Wait for the task to complete\nmanager.wait_for_task_id(task.id)\n\n# Check if the task was successful\nif task.successful():\n    print(\"Task completed successfully. The current date is stored in 'current_date'.\")\nelse:\n    print(\"Task failed.\")\n\n# Shutdown the manager\nmanager.cancel_all()\nmanager.wait()\n```"
        }
    ]
}
