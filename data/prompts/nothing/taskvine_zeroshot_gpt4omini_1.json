[
    {
        "id": "taskvine0",
        "content": "Write a Python TaskVine application to get the current date on a worker machine. The date must be stored to an output file named \"current_date\".",
        "response": "```python\nimport datetime\n\ndef write_current_date_to_file():\n    current_date = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    with open(\"current_date\", \"w\") as file:\n        file.write(current_date)\n\nif __name__ == \"__main__\":\n    write_current_date_to_file()\n```"
    },
    {
        "id": "taskvine1",
        "content": "Write a Python TaskVine application to count the number of times the keywords \"wealth\", \"nation\", \"labour\", \"price\", \"nature\", and \"commodity\" appear in Adam Smith's Wealth of Nations. The text is available at \"https://www.gutenberg.org/cache/epub/3300/pg3300.txt\".",
        "response": "```python\nimport requests\n\n# Define the keywords to search for\nkeywords = [\"wealth\", \"nation\", \"labour\", \"price\", \"nature\", \"commodity\"]\n\n# Fetch the text from the URL\nresponse = requests.get(\"https://www.gutenberg.org/cache/epub/3300/pg3300.txt\")\ntext = response.text\n\n# Initialize a dictionary to hold the count of each keyword\nkeyword_counts = {keyword: 0 for keyword in keywords}\n\n# Count occurrences of each keyword in the text\nfor keyword in keywords:\n    keyword_counts[keyword] = text.lower().count(keyword)\n\n# Print the results\nfor keyword, count in keyword_counts.items():\n    print(f\"'{keyword}': {count}\")\n```"
    },
    {
        "id": "taskvine2",
        "content": "Write a Python TaskVine application to run my program \"script.sh\" with various input arguments and organizes all output data. \"script.sh\" takes, as input, an integer and two files. \"script.sh\" outputs a file named \"output{i}.txt\" where \"{i}\" is the input integer. The application must run \"script.sh\" with input integers 1-1000 and input files \"file1.input\" and \"file2.input\" which are stored in the directory \"script_inputs\". The application must store all output files in a directory named \"script_outputs\".",
        "response": "```python\nimport os\nimport subprocess\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Directories\ninput_directory = 'script_inputs'\noutput_directory = 'script_outputs'\nscript_name = 'script.sh'\n\n# Create output directory if it doesn't exist\nos.makedirs(output_directory, exist_ok=True)\n\ndef run_script(i):\n    \"\"\"Function to run the script with given integer and input files.\"\"\"\n    input_file1 = os.path.join(input_directory, 'file1.input')\n    input_file2 = os.path.join(input_directory, 'file2.input')\n    output_file = os.path.join(output_directory, f'output{i}.txt')\n    \n    # Run the script with subprocess\n    with open(output_file, 'w') as outfile:\n        subprocess.run(['bash', script_name, str(i), input_file1, input_file2], stdout=outfile, stderr=subprocess.STDOUT)\n\ndef main():\n    # Using ThreadPoolExecutor to run multiple instances in parallel\n    with ThreadPoolExecutor() as executor:\n        executor.map(run_script, range(1, 1001))\n\nif __name__ == '__main__':\n    main()\n```\n"
    },
    {
        "id": "taskvine3",
        "content": "Write a Python TaskVine application to execute a pipeline of shell scripts. I have the script \"script1.sh\" which outputs a file named \"intermediary.out\" upon completion. I also have the scripts \"script2.sh\" and \"script3.sh\"  which both accept an input file as a command line argument. \"script2.sh\" and \"script3.sh\" must both receive \"intermediary.out\" as the input. Finally, \"script2.sh\" and \"script3.sh\" output files named \"script2.out\" and \"script3.out\", respectively. Save these outputs files on the host machine. \"intermediary.out\" need not be saved to the host machine.",
        "response": "To create a TaskVine application that executes a pipeline of shell scripts in the described manner, you can use the following Python code. This code handles the execution flow of the shell scripts and manages the output files as specified.\n\n```python\nimport subprocess\nimport os\n\nclass TaskVine:\n    def run_pipeline(self):\n        self.execute_script('script1.sh')\n\n        input_file = 'intermediary.out'\n        self.execute_script('script2.sh', input_file)\n        self.execute_script('script3.sh', input_file)\n\n    def execute_script(self, script_name, input_file=None):\n        command = [script_name]\n        if input_file:\n            command.append(input_file)\n        \n        try:\n            print(f'Executing: {\" \".join(command)}')\n            subprocess.run(command, check=True)\n            print(f'Successfully executed {script_name}')\n\n            # If the script produces an output file, move it to the specified destination\n            self.handle_output(script_name)\n        except subprocess.CalledProcessError as e:\n            print(f\"Error executing {script_name}: {e}\")\n\n    def handle_output(self, script_name):\n        if script_name == 'script2.sh':\n            output_file = 'script2.out'\n        elif script_name == 'script3.sh':\n            output_file = 'script3.out'\n        else:\n            return\n\n        # Move the output file to the host machine or specified directory if needed\n        print(f'Moving output file: {output_file}')\n        # Here you can add code to move or save the output file as needed.\n        # Currently, it just assumes the script handles output directly.\n\nif __name__ == \"__main__\":\n    app = TaskVine()\n    app.run_pipeline()\n```\n\n### Explanation:\n1. **TaskVine Class**: This class manages the execution of the pipeline.\n2. **run_pipeline Method**: It executes `script1.sh`, then runs `script2.sh` and `script3.sh` using the intermediary output file.\n3. **execute_script Method**: Executes a given script and checks if it was successful. If it was, it handles the output.\n4. **handle_output Method**: This checks which script was executed and prepares to handle the output file appropriately. Note that actual file management logic can be added.\n\n### Usage:\n- Make sure your shell scripts are executable.\n- The intermediary output 'intermediary.out' will be created but not saved per your instructions.\n- The output files 'script2.out' and 'script3.out' will be printed as being moved, but you can expand the logic to actually save or process them as needed."
    },
    {
        "id": "taskvine4",
        "content": "Write a Python TaskVine application to run my GPU-accelerated program. The program binary is stored at \"./train_demo\". The program requires that the worker machine has the feature \"NVIDIA RTX 4090\". Upon completion, the program outputs \"model.tar.gz\". The output file must be saved to the host machine.",
        "response": "```python\nimport taskvine as tv\n\n# Create a task for running the GPU-accelerated program\nclass TrainTask(tv.Task):\n    def run(self):\n        # Execute the program binary\n        tv.run_command(\"./train_demo\")\n\n# Create a Job to run the task with specific requirements\nclass TrainJob(tv.Job):\n    def __init__(self):\n        super().__init__()\n        self.add_task(TrainTask())\n        \n        # Define the requirement for the GPU\n        self.requirements = {\n            \"features\": [\"NVIDIA RTX 4090\"]\n        }\n\n    def on_complete(self):\n        # Specify the output file to save to the host machine\n        tv.save_output_file(\"model.tar.gz\", \"./model.tar.gz\")\n\n# Create the TaskVine application\nif __name__ == \"__main__\":\n    app = tv.Application()\n    app.add_job(TrainJob())\n    app.run()\n```"
    },
    {
        "id": "taskvine5",
        "content": "Write a Python TaskVine application to compile and test my project stored at \"complex_project/\". To compile the project, run the \"make all\" command in the project's root directory. Then, to test the project, run \"make test\". The compilation and test must use at most 4 cores, 1024 MB of memory, and 2048 MB of disk. Enable resource monitoring to track resource usage, but do not terminate the task if it overuses resources. When the task completes, print the task's exit code and standard output. For each resource that the task overused, print the resource and by how much it overused.",
        "response": "```python\nimport os\nimport subprocess\nimport resource\n\nclass TaskVine:\n    def __init__(self, project_dir):\n        self.project_dir = project_dir\n        self.resource_limits = {\n            'memory': 1024 * 1024 * 1024,  # 1024 MB in Bytes\n            'disk': 2048 * 1024 * 1024,     # 2048 MB in Bytes\n            'cores': 4                       # Max cores\n        }\n\n    def set_resource_limits(self):\n        resource.setrlimit(resource.RLIMIT_AS, (self.resource_limits['memory'], resource.RLIM_INFINITY))  # Memory limit\n        # Note: Disk limits aren't directly applicable at the process level in Python\n        # Thus, we handle them ourselves in the task management, but here is a placeholder. \n        print(\"Resource limits set.\")\n\n    def run_command(self, command):\n        try:\n            result = subprocess.run(command, shell=True, cwd=self.project_dir, \n                                   stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n            return result\n        except Exception as e:\n            print(f\"Error running command '{command}': {e}\")\n            return None\n\n    def compile_project(self):\n        print(\"Compiling project...\")\n        compile_result = self.run_command(\"make all\")\n        return compile_result\n\n    def test_project(self):\n        print(\"Testing project...\")\n        test_result = self.run_command(\"make test\")\n        return test_result\n\n    def monitor_resource_usage(self):\n        usage = {\n            'memory': resource.getrusage(resource.RUSAGE_SELF).ru_maxrss,\n            # Disk usage is more complex; placeholder logic here.\n        }\n        return usage\n\n    def report_resource_usage(self, initial_usage, final_usage):\n        for resource_name, initial_amount in initial_usage.items():\n            final_amount = final_usage.get(resource_name, 0)\n            if final_amount > initial_amount:\n                print(f\"Overused {resource_name} by {final_amount - initial_amount} bytes\")\n\n    def run(self):\n        self.set_resource_limits()\n        initial_usage = self.monitor_resource_usage()\n\n        compile_result = self.compile_project()\n        print(f\"Compile Exit Code: {compile_result.returncode}\\nCompile Output: {compile_result.stdout}\\nCompile Errors: {compile_result.stderr}\")\n\n        test_result = self.test_project()\n        print(f\"Test Exit Code: {test_result.returncode}\\nTest Output: {test_result.stdout}\\nTest Errors: {test_result.stderr}\")\n\n        final_usage = self.monitor_resource_usage()\n        self.report_resource_usage(initial_usage, final_usage)\n\nif __name__ == \"__main__\":\n    task_vine_app = TaskVine(project_dir=\"complex_project/\")\n    task_vine_app.run()\n```"
    },
    {
        "id": "taskvine6",
        "content": "Write a Python TaskVine application that executes multiple programs with different levels of resource requirements. The two task categories must be named \"intensive\" and \"light\". The \"intensive\" tasks require 8 cores and 16 GB of memory. The \"light\" tasks require 1 core and 2 GB of memory. In the intensive category, submit 10 tasks to execute the shell script \"intensive.sh\". In the light category, submit 100 tasks to execute the shell script \"light.sh\" Print the standard output of each task upon completion.",
        "response": "Here's a Python TaskVine application that submits the specified tasks under the \"intensive\" and \"light\" categories. Make sure you have TaskVine library installed in your environment.\n\n```python\nimport taskvine\nimport subprocess\n\n# Create the TaskVine application\napp = taskvine.Application()\n\n# Define the resource requirements for each category\nintensive_resources = {'cores': 8, 'memory': '16GB'}\nlight_resources = {'cores': 1, 'memory': '2GB'}\n\n# Create Task Categories\nintensive_category = app.create_category(\"intensive\", intensive_resources)\nlight_category = app.create_category(\"light\", light_resources)\n\n# Submit Intensive Tasks\nintensive_tasks = []\nfor i in range(10):\n    task = intensive_category.submit(\"bash intensive.sh\")\n    intensive_tasks.append(task)\n\n# Submit Light Tasks\nlight_tasks = []\nfor i in range(100):\n    task = light_category.submit(\"bash light.sh\")\n    light_tasks.append(task)\n\n# Collect and print output for intensive tasks\nfor task in intensive_tasks:\n    output = task.wait_for_completion()\n    print(f\"Intensive Task {task.id} Output:\\n{output}\\n\")\n\n# Collect and print output for light tasks\nfor task in light_tasks:\n    output = task.wait_for_completion()\n    print(f\"Light Task {task.id} Output:\\n{output}\\n\")\n```\n\nThis script creates an application, defines two categories of tasks with the specified resource requirements, submits the tasks, waits for their completion, and prints the output of each task. Make sure that `intensive.sh` and `light.sh` are executable shell scripts in the same directory as this script or provide their full paths."
    },
    {
        "id": "taskvine7",
        "content": "Write a Python TaskVine application to perform matrix inversion and transposition. The matrix computations must be defined in Python functions and added to a TaskVine library called \"matrix_library\". The user must specify the size, m x n,  of the matrix and the number of matrices, i, on which to perform computation. The application must randomly generate i matrices and for each matrix, print the matrix, print the inverse matrix, and print the transposed matrix.",
        "response": "Here's a complete Python TaskVine application that creates a library named `matrix_library` where matrix inversion and transposition functions are defined, and then randomly generates matrices as specified by the user.\n\nFirst, create a Python file named `matrix_library.py` and add the following code to define the necessary functions:\n\n```python\n# matrix_library.py\nimport numpy as np\n\ndef generate_random_matrix(m, n):\n    \"\"\"Generates a random m x n matrix.\"\"\"\n    return np.random.rand(m, n)\n\ndef invert_matrix(matrix):\n    \"\"\"Returns the inverse of a square matrix.\"\"\"\n    if matrix.shape[0] != matrix.shape[1]:\n        raise ValueError(\"Matrix must be square to invert.\")\n    return np.linalg.inv(matrix)\n\ndef transpose_matrix(matrix):\n    \"\"\"Returns the transpose of a matrix.\"\"\"\n    return np.transpose(matrix)\n\n```\n\nNext, create the main application code in another Python file named `matrix_app.py`:\n\n```python\n# matrix_app.py\nimport numpy as np\nfrom matrix_library import generate_random_matrix, invert_matrix, transpose_matrix\n\ndef main():\n    m = int(input(\"Enter the number of rows (m): \"))\n    n = int(input(\"Enter the number of columns (n): \"))\n    i = int(input(\"Enter the number of matrices to generate (i): \"))\n    \n    for j in range(i):\n        print(f\"\\nMatrix {j + 1}:\")\n        matrix = generate_random_matrix(m, n)\n        print(matrix)\n        \n        if m == n:  # Only invert if it's a square matrix\n            try:\n                inv_matrix = invert_matrix(matrix)\n                print(\"Inverse matrix:\")\n                print(inv_matrix)\n            except ValueError as e:\n                print(e)\n        else:\n            print(\"Cannot compute inverse for a non-square matrix.\")\n        \n        trans_matrix = transpose_matrix(matrix)\n        print(\"Transposed matrix:\")\n        print(trans_matrix)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTo run the application:\n\n1. Make sure you have `numpy` installed in your Python environment. If not, install it using:\n   ```bash\n   pip install numpy\n   ```\n\n2. Run the `matrix_app.py` script:\n   ```bash\n   python matrix_app.py\n   ```\n\nFollow the prompts to input the matrix dimensions and the number of matrices. The program will display each matrix along with its inverse (if applicable) and its transposed version."
    },
    {
        "id": "taskvine8",
        "content": "Write a Python Taskvine application to fetch the titles of multiple news webpages. The webpage contents must be downloaded asynchronously using the TaskVine futures executor. Print the URL and title of each webpage in order of the completion of each task. The webpages I am interested in are \"https://abcnews.com\", \"https://apnews.com\", \"https://axios.com\", \"https://cnn.com\", \"https://nbcnews.com\", \"https://nytimes.com\", \"https://reuters.com\", \"https://washingtonpost.com\", \"https://wsj.com\".",
        "response": "```python\nimport asyncio\nimport aiohttp\nfrom taskvine import futures\n\nasync def fetch_title(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            if response.status == 200:\n                html = await response.text()\n                title_start = html.find('<title>') + len('<title>')\n                title_end = html.find('</title>', title_start)\n                title = html[title_start:title_end]\n                return url, title\n            else:\n                return url, None\n\nasync def main(urls):\n    tasks = [fetch_title(url) for url in urls]\n    results = await asyncio.gather(*tasks)\n    for url, title in results:\n        print(f'URL: {url}, Title: {title}')\n\nif __name__ == \"__main__\":\n    urls = [\n        \"https://abcnews.com\",\n        \"https://apnews.com\",\n        \"https://axios.com\",\n        \"https://cnn.com\",\n        \"https://nbcnews.com\",\n        \"https://nytimes.com\",\n        \"https://reuters.com\",\n        \"https://washingtonpost.com\",\n        \"https://wsj.com\"\n    ]\n\n    with futures.ThreadPoolExecutor() as executor:\n        loop = asyncio.get_event_loop()\n        loop.run_in_executor(executor, main(urls))\n```"
    },
    {
        "id": "taskvine9",
        "content": "Write a Python TaskVine application to get the current date on a worker machine. The date must be stored to an output file named \"current_date\". To prevent an unwanted worker from connecting to the manager, use the password stored in the file \"taskvine.password\". Further, encrypt communication between the manager and worker with SSL using the \"key.pem\" and \"certificate.pem\" files.",
        "response": "Here's a Python TaskVine application that gets the current date on a worker machine, stores it in an output file named \"current_date\", and uses SSL for secure communication. The application also uses a password from \"taskvine.password\" for authentication.\n\n```python\nimport os\nimport ssl\nimport socket\nfrom datetime import datetime\nfrom taskvine import TaskVine, Worker\n\ndef get_current_date():\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\ndef write_date_to_file(date_string):\n    with open(\"current_date\", \"w\") as file:\n        file.write(date_string)\n\ndef main():\n    # Load password from the file\n    with open(\"taskvine.password\", \"r\") as password_file:\n        password = password_file.read().strip()\n\n    # Create a TaskVine Worker\n    worker = Worker(password=password)\n\n    # Create an SSL context\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    context.load_cert_chain(certfile=\"certificate.pem\", keyfile=\"key.pem\")\n\n    # Bind the worker to an SSL socket\n    with socket.create_server(('localhost', 8000), family=socket.AF_INET) as server_socket:\n        server_socket = context.wrap_socket(server_socket, server_side=True)\n\n        # Worker loop\n        while True:\n            conn, addr = server_socket.accept()\n            with conn:\n                date_string = get_current_date()\n                write_date_to_file(date_string)\n                print(f\"Current date written to file: {date_string}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nMake sure you have the required packages and correct file paths for the SSL certificates and password file to run this application."
    }
]
